package game

import (
	"context"
	"testing"
)

// TestAdvancedAntiExploitation contains more sophisticated exploitation scenarios
func TestAdvancedAntiExploitation(t *testing.T) {

	t.Run("PreventDoubleActionInSameTurn", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		currentPlayer := engine.getCurrentActionPlayerID()

		// First action: call
		firstAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: currentPlayer,
			Data: map[string]interface{}{
				"action": "call",
			},
		}

		_, err := engine.ProcessAction(context.Background(), firstAction)
		if err != nil {
			t.Fatalf("First action should succeed: %v", err)
		}

		// Try to take another action in the same turn (should fail because turn advanced)
		secondAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: currentPlayer,
			Data: map[string]interface{}{
				"action": "raise",
				"amount": 50,
			},
		}

		err = engine.IsValidAction(secondAction)
		if err == nil {
			t.Error("Should not allow multiple actions in the same turn")
		}
	})

	t.Run("PreventManipulatingCompletedGame", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		// Force game to end by making one player fold
		currentPlayer := engine.getCurrentActionPlayerID()
		foldAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: currentPlayer,
			Data: map[string]interface{}{
				"action": "fold",
			},
		}

		_, err := engine.ProcessAction(context.Background(), foldAction)
		if err != nil {
			t.Fatalf("Fold should succeed: %v", err)
		}

		// Game should be finished now
		if engine.GetState() != GameStateFinished {
			t.Fatal("Game should be finished after one player folds")
		}

		// Try to take action in completed game
		remainingPlayer := ""
		for _, p := range engine.players {
			holdemPlayer := engine.getHoldemPlayer(p.ID)
			if !holdemPlayer.HasFolded {
				remainingPlayer = p.ID
				break
			}
		}

		postGameAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: remainingPlayer,
			Data: map[string]interface{}{
				"action": "bet",
				"amount": 100,
			},
		}

		err = engine.IsValidAction(postGameAction)
		if err == nil {
			t.Error("Should not allow actions after game is completed")
		}
	})

	t.Run("PreventExtremelyLargeAmounts", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		currentPlayer := engine.getCurrentActionPlayerID()

		// Try extremely large amounts (potential integer overflow attack)
		largeAmounts := []interface{}{
			float64(1e20),                // Very large float
			int(2147483647),              // Max int32
			float64(9223372036854775807), // Near max int64 as float
		}

		for i, amount := range largeAmounts {
			action := &GameAction{
				Type:     "texas_holdem_action",
				PlayerID: currentPlayer,
				Data: map[string]interface{}{
					"action": "raise",
					"amount": amount,
				},
			}

			// The validation should pass (positive number), but processing should clamp to available chips
			err := engine.IsValidAction(action)
			if err != nil {
				t.Errorf("Large amount %d should be valid but clamped: %v", i, err)
			}
		}
	})

	t.Run("PreventNaNAndInfinityAmounts", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		currentPlayer := engine.getCurrentActionPlayerID()

		// Note: Go's JSON unmarshaling typically handles these, but we test anyway
		problematicAmounts := []interface{}{
			"NaN",
			"Infinity",
			"-Infinity",
			"null",
			nil,
		}

		for i, amount := range problematicAmounts {
			action := &GameAction{
				Type:     "texas_holdem_action",
				PlayerID: currentPlayer,
				Data: map[string]interface{}{
					"action": "raise",
					"amount": amount,
				},
			}

			err := engine.IsValidAction(action)
			if err == nil {
				t.Errorf("Problematic amount %d (%v) should be rejected", i, amount)
			}
		}
	})

	t.Run("PreventActionsWithMissingData", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		currentPlayer := engine.getCurrentActionPlayerID()

		// Test with nil Data field
		nilDataAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: currentPlayer,
			Data:     nil,
		}

		err := engine.IsValidAction(nilDataAction)
		if err == nil {
			t.Error("Should reject action with nil Data")
		}
	})

	t.Run("PreventRepeatedProcessingOfSameAction", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		currentPlayer := engine.getCurrentActionPlayerID()

		action := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: currentPlayer,
			Data: map[string]interface{}{
				"action": "call",
			},
		}

		// Process the action once
		_, err := engine.ProcessAction(context.Background(), action)
		if err != nil {
			t.Fatalf("First processing should succeed: %v", err)
		}

		// Try to process the same action again (should fail because turn changed)
		_, err = engine.ProcessAction(context.Background(), action)
		if err == nil {
			t.Error("Should not allow processing the same action twice")
		}
	})

	t.Run("PreventCardDeckManipulation", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		// Check that deck is properly protected (cards already dealt)
		if engine.deck.Remaining() != 48 { // 52 - 4 hole cards
			t.Errorf("Expected deck size 48 after dealing hole cards, got %d", engine.deck.Remaining())
		}

		// Verify players can't somehow access deck state
		for _, p := range engine.players {
			holdemPlayer := engine.getHoldemPlayer(p.ID)
			if holdemPlayer.Hand.Size() != 2 {
				t.Errorf("Player %s should have exactly 2 hole cards, got %d", p.ID, holdemPlayer.Hand.Size())
			}
		}
	})

	t.Run("PreventInvalidPlayerStateManipulation", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		// Verify initial player states are correct
		for _, p := range engine.players {
			holdemPlayer := engine.getHoldemPlayer(p.ID)

			// Check chips are within reasonable bounds
			if holdemPlayer.Chips < 985 || holdemPlayer.Chips > 1000 {
				t.Errorf("Player %s has suspicious chip count: %d", p.ID, holdemPlayer.Chips)
			}

			// Check no player starts folded or all-in
			if holdemPlayer.HasFolded {
				t.Errorf("Player %s should not start folded", p.ID)
			}
			if holdemPlayer.IsAllIn && holdemPlayer.Chips > 0 {
				t.Errorf("Player %s marked all-in but has chips", p.ID)
			}
		}
	})

	t.Run("PreventConcurrentActionProcessing", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		currentPlayer := engine.getCurrentActionPlayerID()

		action := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: currentPlayer,
			Data: map[string]interface{}{
				"action": "call",
			},
		}

		// Test rapid-fire submission (simulating race condition attempt)
		results := make([]error, 2)
		done := make(chan bool, 2)

		for i := 0; i < 2; i++ {
			go func(index int) {
				_, err := engine.ProcessAction(context.Background(), action)
				results[index] = err
				done <- true
			}(i)
		}

		// Wait for both goroutines
		<-done
		<-done

		// Exactly one should succeed, one should fail
		successCount := 0
		for _, err := range results {
			if err == nil {
				successCount++
			}
		}

		if successCount != 1 {
			t.Errorf("Expected exactly 1 success out of 2 concurrent actions, got %d", successCount)
		}
	})
}
