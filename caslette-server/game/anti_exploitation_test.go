package game

import (
	"context"
	"testing"
)

// TestAntiExploitation contains comprehensive tests to prevent cheating and exploitation
func TestAntiExploitation(t *testing.T) {

	t.Run("PreventOutOfTurnActions", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		// Add 3 players
		for i := 1; i <= 3; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		// Try to act when it's not your turn
		currentPlayer := engine.getCurrentActionPlayerID()

		// Find a different player
		var wrongPlayer string
		for _, p := range engine.players {
			if p.ID != currentPlayer {
				wrongPlayer = p.ID
				break
			}
		}

		wrongAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: wrongPlayer,
			Data: map[string]interface{}{
				"action": "fold",
			},
		}

		err := engine.IsValidAction(wrongAction)
		if err == nil {
			t.Error("Should not allow out-of-turn actions")
		}

		// Verify the game state hasn't changed
		stillCurrentPlayer := engine.getCurrentActionPlayerID()
		if stillCurrentPlayer != currentPlayer {
			t.Errorf("Current player changed when it shouldn't have: %s -> %s", currentPlayer, stillCurrentPlayer)
		}
	})

	t.Run("PreventNegativeAmounts", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		currentPlayer := engine.getCurrentActionPlayerID()

		// Try negative bet
		negativeBetAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: currentPlayer,
			Data: map[string]interface{}{
				"action": "raise",
				"amount": -100,
			},
		}

		err := engine.IsValidAction(negativeBetAction)
		if err == nil {
			t.Error("Should not allow negative bet amounts")
		}

		// Try zero bet
		zeroBetAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: currentPlayer,
			Data: map[string]interface{}{
				"action": "raise",
				"amount": 0,
			},
		}

		err = engine.IsValidAction(zeroBetAction)
		if err == nil {
			t.Error("Should not allow zero bet amounts")
		}
	})

	t.Run("PreventBettingMoreThanChips", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		currentPlayer := engine.getCurrentActionPlayerID()
		holdemPlayer := engine.getHoldemPlayer(currentPlayer)

		// Try to bet more than available chips
		oversizedBetAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: currentPlayer,
			Data: map[string]interface{}{
				"action": "raise",
				"amount": holdemPlayer.Chips + 1000, // Way more than they have
			},
		}

		// This should be processed as all-in, not rejected
		initialChips := holdemPlayer.Chips
		_, err := engine.ProcessAction(context.Background(), oversizedBetAction)
		if err != nil {
			t.Errorf("Oversized bet should be clamped to available chips, not error: %v", err)
		}

		// Verify chips were handled correctly (should be all-in)
		updatedPlayer := engine.getHoldemPlayer(currentPlayer)
		if updatedPlayer.Chips != 0 {
			t.Errorf("Player should be all-in (0 chips), but has %d chips", updatedPlayer.Chips)
		}
		if !updatedPlayer.IsAllIn {
			t.Error("Player should be marked as all-in")
		}
		if updatedPlayer.TotalBet < initialChips {
			t.Errorf("Player's total bet should be at least their initial chips (%d), got %d", initialChips, updatedPlayer.TotalBet)
		}
	})

	t.Run("PreventActionsFromFoldedPlayers", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		currentPlayer := engine.getCurrentActionPlayerID()

		// Player folds
		foldAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: currentPlayer,
			Data: map[string]interface{}{
				"action": "fold",
			},
		}

		_, err := engine.ProcessAction(context.Background(), foldAction)
		if err != nil {
			t.Fatalf("Fold action should succeed: %v", err)
		}

		// Try to act again after folding
		attemptSecondAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: currentPlayer,
			Data: map[string]interface{}{
				"action": "call",
			},
		}

		err = engine.IsValidAction(attemptSecondAction)
		if err == nil {
			t.Error("Folded players should not be able to take actions")
		}
	})

	t.Run("PreventActionsFromAllInPlayers", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		// Add players with limited chips to force all-in
		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		currentPlayer := engine.getCurrentActionPlayerID()
		holdemPlayer := engine.getHoldemPlayer(currentPlayer)

		// Force player to go all-in by betting all their chips
		allInAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: currentPlayer,
			Data: map[string]interface{}{
				"action": "raise",
				"amount": holdemPlayer.Chips - holdemPlayer.CurrentBet, // Bet remaining chips
			},
		}

		_, err := engine.ProcessAction(context.Background(), allInAction)
		if err != nil {
			t.Fatalf("All-in action should succeed: %v", err)
		}

		// Verify player is all-in
		updatedPlayer := engine.getHoldemPlayer(currentPlayer)
		if !updatedPlayer.IsAllIn {
			t.Fatal("Player should be marked as all-in")
		}

		// Move to next betting round to get them as current player again
		// (This is a bit contrived but tests the validation)
		if engine.getCurrentActionPlayerID() == currentPlayer {
			// Try to act when all-in
			attemptAction := &GameAction{
				Type:     "texas_holdem_action",
				PlayerID: currentPlayer,
				Data: map[string]interface{}{
					"action": "raise",
					"amount": 50,
				},
			}

			err = engine.IsValidAction(attemptAction)
			if err == nil {
				t.Error("All-in players should not be able to take actions")
			}
		}
	})

	t.Run("PreventInvalidActionTypes", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		currentPlayer := engine.getCurrentActionPlayerID()

		invalidActions := []string{
			"cheat",
			"peek",
			"double_bet",
			"steal_chips",
			"",
			"null",
		}

		for _, invalidAction := range invalidActions {
			action := &GameAction{
				Type:     "texas_holdem_action",
				PlayerID: currentPlayer,
				Data: map[string]interface{}{
					"action": invalidAction,
				},
			}

			err := engine.IsValidAction(action)
			if err == nil {
				t.Errorf("Invalid action '%s' should be rejected", invalidAction)
			}
		}
	})

	t.Run("PreventMalformedActionData", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		currentPlayer := engine.getCurrentActionPlayerID()

		// Test malformed data scenarios
		malformedActions := []*GameAction{
			// Missing action field
			{
				Type:     "texas_holdem_action",
				PlayerID: currentPlayer,
				Data:     map[string]interface{}{},
			},
			// Action is wrong type
			{
				Type:     "texas_holdem_action",
				PlayerID: currentPlayer,
				Data: map[string]interface{}{
					"action": 123, // Should be string
				},
			},
			// Amount is wrong type for raise
			{
				Type:     "texas_holdem_action",
				PlayerID: currentPlayer,
				Data: map[string]interface{}{
					"action": "raise",
					"amount": "fifty", // Should be number
				},
			},
		}

		for i, action := range malformedActions {
			err := engine.IsValidAction(action)
			if err == nil {
				t.Errorf("Malformed action %d should be rejected", i)
			}
		}
	})

	t.Run("PreventActionsInWrongGameState", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		player := &Player{
			ID:   "1",
			Name: "Player 1",
		}
		engine.AddPlayer(player)

		// Try action before game starts
		action := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: "1",
			Data: map[string]interface{}{
				"action": "fold",
			},
		}

		err := engine.IsValidAction(action)
		if err == nil {
			t.Error("Should not allow actions before game starts")
		}

		// Start and finish game
		engine.AddPlayer(&Player{ID: "2", Name: "Player 2"})
		engine.Start()
		engine.SetState(GameStateFinished)

		// Try action after game ends
		err = engine.IsValidAction(action)
		if err == nil {
			t.Error("Should not allow actions after game ends")
		}
	})

	t.Run("PreventCheckWhenBetExists", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		// First player raises (creates a bet)
		currentPlayer := engine.getCurrentActionPlayerID()
		raiseAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: currentPlayer,
			Data: map[string]interface{}{
				"action": "raise",
				"amount": 50,
			},
		}

		_, err := engine.ProcessAction(context.Background(), raiseAction)
		if err != nil {
			t.Fatalf("Raise should succeed: %v", err)
		}

		// Next player tries to check when there's a bet to call
		nextPlayer := engine.getCurrentActionPlayerID()
		checkAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: nextPlayer,
			Data: map[string]interface{}{
				"action": "check",
			},
		}

		err = engine.IsValidAction(checkAction)
		if err == nil {
			t.Error("Should not allow check when there's a bet to call")
		}
	})

	t.Run("PreventBetWhenBetExists", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		// Current bet exists from big blind
		currentPlayer := engine.getCurrentActionPlayerID()

		// Try to bet when big blind already created a bet
		betAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: currentPlayer,
			Data: map[string]interface{}{
				"action": "bet",
				"amount": 50,
			},
		}

		err := engine.IsValidAction(betAction)
		if err == nil {
			t.Error("Should not allow bet when there's already a bet (should use raise)")
		}
	})

	t.Run("PreventCallWhenNoCall", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		// Move to flop where no bet exists
		currentPlayer := engine.getCurrentActionPlayerID()

		// Call to match big blind first
		callAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: currentPlayer,
			Data: map[string]interface{}{
				"action": "call",
			},
		}
		_, err := engine.ProcessAction(context.Background(), callAction)
		if err != nil {
			t.Fatalf("Initial call should work: %v", err)
		}

		// Big blind checks to advance to flop
		nextPlayer := engine.getCurrentActionPlayerID()
		checkAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: nextPlayer,
			Data: map[string]interface{}{
				"action": "check",
			},
		}
		_, err = engine.ProcessAction(context.Background(), checkAction)
		if err != nil {
			t.Fatalf("Check should work: %v", err)
		}

		// Now in flop with no current bet - try to call
		if engine.roundState == Flop {
			flopPlayer := engine.getCurrentActionPlayerID()
			callInFlop := &GameAction{
				Type:     "texas_holdem_action",
				PlayerID: flopPlayer,
				Data: map[string]interface{}{
					"action": "call",
				},
			}

			err = engine.IsValidAction(callInFlop)
			if err == nil {
				t.Error("Should not allow call when player's bet equals current bet")
			}
		}
	})

	t.Run("PreventNonExistentPlayerActions", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		// Try action from non-existent player
		ghostAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: "ghost_player",
			Data: map[string]interface{}{
				"action": "fold",
			},
		}

		err := engine.IsValidAction(ghostAction)
		if err == nil {
			t.Error("Should not allow actions from non-existent players")
		}
	})

	t.Run("PreventEmptyPlayerID", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		// Try action with empty player ID
		emptyPlayerAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: "",
			Data: map[string]interface{}{
				"action": "fold",
			},
		}

		err := engine.IsValidAction(emptyPlayerAction)
		if err == nil {
			t.Error("Should not allow actions with empty player ID")
		}
	})
}
