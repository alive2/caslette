package game

import (
	"context"
	"math"
	"strings"
	"testing"
	"time"
)

// TestSophisticatedExploits contains advanced attack scenarios that sophisticated exploiters might attempt
func TestSophisticatedExploits(t *testing.T) {

	t.Run("PreventTimingAttacks", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		currentPlayer := engine.getCurrentActionPlayerID()

		// Measure action processing time for different scenarios
		// Exploiters might try to infer information from processing time differences

		// Test 1: Normal call
		start := time.Now()
		action1 := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: currentPlayer,
			Data: map[string]interface{}{
				"action": "call",
			},
		}
		_, err := engine.ProcessAction(context.Background(), action1)
		duration1 := time.Since(start)

		if err != nil {
			t.Fatalf("Valid action should succeed: %v", err)
		}

		// Test 2: Action from next player
		nextPlayer := engine.getCurrentActionPlayerID()
		start = time.Now()
		action2 := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: nextPlayer,
			Data: map[string]interface{}{
				"action": "check",
			},
		}
		_, err = engine.ProcessAction(context.Background(), action2)
		duration2 := time.Since(start)

		if err != nil {
			t.Fatalf("Valid action should succeed: %v", err)
		}

		// Processing times shouldn't vary dramatically for valid actions
		// (This is a basic timing attack protection test)
		ratio := float64(duration1) / float64(duration2)
		if ratio > 10.0 || ratio < 0.1 {
			t.Logf("Warning: Processing time variance detected (ratio: %.2f). This could leak information.", ratio)
		}
	})

	t.Run("PreventMemoryLeaksFromMaliciousInputs", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		currentPlayer := engine.getCurrentActionPlayerID()

		// Try actions with extremely large string inputs (potential DoS)
		largeString := strings.Repeat("A", 1000000) // 1MB string

		maliciousAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: currentPlayer,
			Data: map[string]interface{}{
				"action":          largeString,
				"malicious_field": largeString,
				"another_field":   largeString,
			},
		}

		err := engine.IsValidAction(maliciousAction)
		if err == nil {
			t.Error("Should reject action with malicious large string data")
		}
	})

	t.Run("PreventFloatPrecisionExploits", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		currentPlayer := engine.getCurrentActionPlayerID()

		// Test precision attacks with very small positive numbers
		precisionAmounts := []float64{
			0.0000001,     // Very small positive
			0.1,           // Small decimal
			1.00000000001, // Slightly above 1
			math.SmallestNonzeroFloat64,
		}

		for i, amount := range precisionAmounts {
			action := &GameAction{
				Type:     "texas_holdem_action",
				PlayerID: currentPlayer,
				Data: map[string]interface{}{
					"action": "raise",
					"amount": amount,
				},
			}

			err := engine.IsValidAction(action)
			// Small positive amounts should be valid but might be problematic in processing
			if err != nil && amount > 0 {
				t.Logf("Amount %f (test %d) rejected: %v", amount, i, err)
			}
		}
	})

	t.Run("PreventInfiniteRecursionAttacks", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		currentPlayer := engine.getCurrentActionPlayerID()

		// Test with circular/nested data structures that could cause infinite recursion
		circularData := make(map[string]interface{})
		circularData["self"] = circularData // Self-reference
		circularData["action"] = "call"

		action := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: currentPlayer,
			Data:     circularData,
		}

		// This should not crash the system or cause infinite recursion
		start := time.Now()
		err := engine.IsValidAction(action)
		duration := time.Since(start)

		if duration > 100*time.Millisecond {
			t.Errorf("Validation took too long (%v), possible infinite recursion", duration)
		}

		if err == nil {
			t.Error("Should reject action with circular data structure")
		}
	})

	t.Run("PreventStateManipulationViaReflection", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		currentPlayer := engine.getCurrentActionPlayerID()

		// Try to manipulate internal state through action data
		manipulationAction := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: currentPlayer,
			Data: map[string]interface{}{
				"action":     "call",
				"chips":      999999,     // Try to set chips
				"currentBet": 0,          // Try to reset current bet
				"hasActed":   false,      // Try to reset action state
				"hasFolded":  false,      // Try to unfold
				"isAllIn":    false,      // Try to un-all-in
				"pot":        0,          // Try to manipulate pot
				"roundState": "finished", // Try to end game
				"dealerPos":  999,        // Try to manipulate positions
			},
		}

		// Process the action and verify no state manipulation occurred
		originalPot := engine.pot
		originalState := engine.GetState()

		_, err := engine.ProcessAction(context.Background(), manipulationAction)
		if err != nil {
			t.Fatalf("Call action should succeed: %v", err)
		}

		// Verify pot wasn't manipulated
		if engine.pot < originalPot {
			t.Error("Pot was illegally decreased through action data")
		}

		// Verify game state wasn't manipulated
		if engine.GetState() != originalState && engine.GetState() != GameStateInProgress {
			t.Error("Game state was illegally manipulated through action data")
		}
	})

	t.Run("PreventChipDuplicationExploit", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		// Record initial chip totals
		initialTotalChips := 0
		for _, p := range engine.players {
			holdemPlayer := engine.getHoldemPlayer(p.ID)
			initialTotalChips += holdemPlayer.Chips
		}
		initialPot := engine.pot
		totalMoney := initialTotalChips + initialPot

		// Perform several actions and verify chip conservation
		for round := 0; round < 3; round++ {
			currentPlayer := engine.getCurrentActionPlayerID()
			if currentPlayer == "" {
				break
			}

			action := &GameAction{
				Type:     "texas_holdem_action",
				PlayerID: currentPlayer,
				Data: map[string]interface{}{
					"action": "call",
				},
			}

			_, err := engine.ProcessAction(context.Background(), action)
			if err != nil && round == 0 {
				// First action should work
				t.Fatalf("Valid action should succeed: %v", err)
			}

			// Verify chip conservation after each action
			currentTotalChips := 0
			for _, p := range engine.players {
				holdemPlayer := engine.getHoldemPlayer(p.ID)
				currentTotalChips += holdemPlayer.Chips
			}
			currentTotal := currentTotalChips + engine.pot

			if currentTotal != totalMoney {
				t.Errorf("Chip duplication detected! Initial: %d, Current: %d", totalMoney, currentTotal)
			}
		}
	})

	t.Run("PreventCardCountingInfoLeak", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		// Verify that players can't access other players' cards through any means
		player1 := engine.getHoldemPlayer("1")
		player2 := engine.getHoldemPlayer("2")

		// Check that hands are properly isolated
		if len(player1.Hand.Cards) != 2 {
			t.Errorf("Player 1 should have 2 cards, got %d", len(player1.Hand.Cards))
		}
		if len(player2.Hand.Cards) != 2 {
			t.Errorf("Player 2 should have 2 cards, got %d", len(player2.Hand.Cards))
		}

		// Verify cards are unique (no duplicates between players)
		cardSet := make(map[string]bool)
		for _, card := range player1.Hand.Cards {
			cardKey := card.String()
			if cardSet[cardKey] {
				t.Errorf("Duplicate card found: %s", cardKey)
			}
			cardSet[cardKey] = true
		}
		for _, card := range player2.Hand.Cards {
			cardKey := card.String()
			if cardSet[cardKey] {
				t.Errorf("Duplicate card found: %s", cardKey)
			}
			cardSet[cardKey] = true
		}

		// Verify deck size is correct (should be 48 remaining)
		if engine.deck.Remaining() != 48 {
			t.Errorf("Deck should have 48 cards remaining, got %d", engine.deck.Remaining())
		}
	})

	t.Run("PreventActionTypeConfusion", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		currentPlayer := engine.getCurrentActionPlayerID()

		// Test various action type confusion attacks
		confusingActions := []map[string]interface{}{
			{
				"type":   "texas_holdem_action", // Wrong field name
				"action": "call",
			},
			{
				"Action": "call", // Wrong case
			},
			{
				"action": "Call", // Wrong case
			},
			{
				"action": " call ", // Whitespace
			},
			{
				"action": "call\n", // Newline
			},
			{
				"action": "call\x00", // Null byte
			},
			{
				"action": []string{"call"}, // Array instead of string
			},
			{
				"action": map[string]string{"type": "call"}, // Object instead of string
			},
		}

		for i, actionData := range confusingActions {
			action := &GameAction{
				Type:     "texas_holdem_action",
				PlayerID: currentPlayer,
				Data:     actionData,
			}

			err := engine.IsValidAction(action)
			if err == nil {
				t.Errorf("Confusing action %d should be rejected: %+v", i, actionData)
			} else {
				t.Logf("Action %d correctly rejected: %v", i, err)
			}
		}
	})

	t.Run("PreventPlayerIdSpoofing", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		currentPlayer := engine.getCurrentActionPlayerID()

		// Test various player ID spoofing attempts
		spoofingAttempts := []string{
			"1\x00",          // Null byte injection
			"1 ",             // Trailing space
			" 1",             // Leading space
			"1\n",            // Newline
			"1\r",            // Carriage return
			"1\t",            // Tab
			"1\u200B",        // Zero-width space
			"１",              // Unicode lookalike
			"1.0",            // Different representation
			"01",             // Leading zero
			"true",           // Boolean as string
			"[\"1\"]",        // JSON array
			"{\"id\":\"1\"}", // JSON object
		}

		for i, spoofedId := range spoofingAttempts {
			action := &GameAction{
				Type:     "texas_holdem_action",
				PlayerID: spoofedId,
				Data: map[string]interface{}{
					"action": "call",
				},
			}

			// Only exact player IDs should be valid
			err := engine.IsValidAction(action)
			if spoofedId != currentPlayer && err == nil {
				t.Errorf("Spoofed player ID %d (%s) should be rejected", i, spoofedId)
			}
		}
	})

	t.Run("PreventBoundaryValueExploits", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}
		engine.Start()

		currentPlayer := engine.getCurrentActionPlayerID()

		// Test boundary values that might cause integer overflow or underflow
		boundaryValues := []interface{}{
			int64(math.MaxInt64),
			int64(math.MinInt64),
			int32(math.MaxInt32),
			int32(math.MinInt32),
			float64(math.MaxFloat64),
			-float64(math.MaxFloat64),
			math.Inf(1),
			math.Inf(-1),
			math.NaN(),
		}

		for i, value := range boundaryValues {
			action := &GameAction{
				Type:     "texas_holdem_action",
				PlayerID: currentPlayer,
				Data: map[string]interface{}{
					"action": "raise",
					"amount": value,
				},
			}

			err := engine.IsValidAction(action)
			// All extreme values should be handled gracefully (rejected or clamped)
			if err == nil {
				// If accepted, verify it doesn't break the system
				holdemPlayer := engine.getHoldemPlayer(currentPlayer)
				if holdemPlayer.Chips < 0 {
					t.Errorf("Boundary value %d caused negative chips", i)
				}
			}
		}
	})

	t.Run("PreventEventSystemExploits", func(t *testing.T) {
		engine := NewTexasHoldemEngine("exploit-test")

		for i := 1; i <= 2; i++ {
			player := &Player{
				ID:   string(rune('0' + i)),
				Name: "Player " + string(rune('0'+i)),
			}
			engine.AddPlayer(player)
		}

		// Subscribe to events and monitor for information leakage
		var receivedEvents []*GameEvent
		engine.SubscribeToEvents(func(event *GameEvent) {
			receivedEvents = append(receivedEvents, event)
		})

		engine.Start()

		// Process some actions and check events
		currentPlayer := engine.getCurrentActionPlayerID()
		action := &GameAction{
			Type:     "texas_holdem_action",
			PlayerID: currentPlayer,
			Data: map[string]interface{}{
				"action": "call",
			},
		}

		_, err := engine.ProcessAction(context.Background(), action)
		if err != nil {
			t.Fatalf("Valid action should succeed: %v", err)
		}

		// Give some time for events to be processed
		time.Sleep(10 * time.Millisecond)

		// Check that events don't leak sensitive information
		for _, event := range receivedEvents {
			// Verify events don't contain other players' hole cards
			if data := event.Data; data != nil {
				if cards, exists := data["hole_cards"]; exists {
					t.Errorf("Event leaked hole cards: %v", cards)
				}
				if privateData, exists := data["private"]; exists {
					t.Errorf("Event leaked private data: %v", privateData)
				}
				// Check for any card information in events
				for key, value := range data {
					if strings.Contains(strings.ToLower(key), "card") {
						t.Logf("Event contains card-related data: %s = %v", key, value)
					}
				}
			}
		}
	})
}
